module SkelHashedLang where

-- Haskell module generated by the BNF converter

import AbsHashedLang
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transKWDataPattern :: KWDataPattern -> Result
transKWDataPattern x = case x of
  KWDataPattern string -> failure x
transPIdent :: PIdent -> Result
transPIdent x = case x of
  PIdent string -> failure x
transProblem :: Problem -> Result
transProblem x = case x of
  Problem blocks -> failure x
transBlock :: Block -> Result
transBlock x = case x of
  BlockVariable variabledeclss -> failure x
  BlockConstant constantdeclss -> failure x
  BlockConstraint constraintdeclss -> failure x
  BlockLet letdeclss -> failure x
  BlockMinimize exp -> failure x
transTInt :: TInt -> Result
transTInt x = case x of
  IntPos integer -> failure x
  IntNeg integer -> failure x
transTDouble :: TDouble -> Result
transTDouble x = case x of
  DoublePos double -> failure x
  DoubleNeg double -> failure x
transNumber :: Number -> Result
transNumber x = case x of
  NumInt tint -> failure x
  NumDouble tdouble -> failure x
transVal :: Val -> Result
transVal x = case x of
  ValFile string -> failure x
  ValDataset string1 string2 -> failure x
  ValPattern kwdatapattern -> failure x
  ValRandom -> failure x
  ValLiteral number -> failure x
transDim :: Dim -> Result
transDim x = case x of
  Dim integer -> failure x
transShape :: Shape -> Result
transShape x = case x of
  ShapeScalar -> failure x
  Shape1D dim -> failure x
  Shape2D dim1 dim2 -> failure x
  Shape3D dim1 dim2 dim3 -> failure x
transVariableDecl :: VariableDecl -> Result
transVariableDecl x = case x of
  VariableNoInit pident shape -> failure x
  VariableWithInit pident shape val -> failure x
transConstantDecl :: ConstantDecl -> Result
transConstantDecl x = case x of
  ConstantDecl pident shape val -> failure x
transLetDecl :: LetDecl -> Result
transLetDecl x = case x of
  LetDecl pident exp -> failure x
transBound :: Bound -> Result
transBound x = case x of
  ConstantBound pident -> failure x
  NumberBound number -> failure x
transConstraintDecl :: ConstraintDecl -> Result
transConstraintDecl x = case x of
  ConstraintLower exp bound -> failure x
  ConstraintUpper exp bound -> failure x
transOffset :: Offset -> Result
transOffset x = case x of
  OffsetPos integer -> failure x
  OffsetNeg integer -> failure x
transRotateAmount :: RotateAmount -> Result
transRotateAmount x = case x of
  RA1D offset -> failure x
  RA2D offset1 offset2 -> failure x
  RA3D offset1 offset2 offset3 -> failure x
transPiecewiseCase :: PiecewiseCase -> Result
transPiecewiseCase x = case x of
  PiecewiseCase number exp -> failure x
  PiecewiseFinalCase exp -> failure x
transExp :: Exp -> Result
transExp x = case x of
  EPlus exp1 exp2 -> failure x
  ERealImag exp1 exp2 -> failure x
  ESubtract exp1 exp2 -> failure x
  EMul exp1 exp2 -> failure x
  EDiv exp1 exp2 -> failure x
  EScale exp1 exp2 -> failure x
  EDot exp1 exp2 -> failure x
  EPower exp tint -> failure x
  EFun pident exp -> failure x
  ERotate rotateamount exp -> failure x
  ENegate exp -> failure x
  ENumDouble double -> failure x
  ENumInteger integer -> failure x
  EIdent pident -> failure x
  EPiecewise exp piecewisecases -> failure x

