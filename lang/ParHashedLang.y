-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParHashedLang where
import AbsHashedLang
import LexHashedLang
import ErrM

}

%name pProblem Problem
%name pBlock Block
%name pListBlock ListBlock
%name pNumber Number
%name pVal Val
%name pDim Dim
%name pShape Shape
%name pVariableDecl VariableDecl
%name pListVariableDecl ListVariableDecl
%name pVariableDeclGroup VariableDeclGroup
%name pListVariableDeclGroup ListVariableDeclGroup
%name pVariableBlock VariableBlock
%name pConstantDecl ConstantDecl
%name pListConstantDecl ListConstantDecl
%name pConstantDeclGroup ConstantDeclGroup
%name pListConstantDeclGroup ListConstantDeclGroup
%name pConstantBlock ConstantBlock
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  ',' { PT _ (TS _ 3) }
  ':' { PT _ (TS _ 4) }
  ';' { PT _ (TS _ 5) }
  '=' { PT _ (TS _ 6) }
  'Dataset' { PT _ (TS _ 7) }
  'File' { PT _ (TS _ 8) }
  'Pattern' { PT _ (TS _ 9) }
  'Random' { PT _ (TS _ 10) }
  '[' { PT _ (TS _ 11) }
  ']' { PT _ (TS _ 12) }
  '{' { PT _ (TS _ 13) }
  '}' { PT _ (TS _ 14) }
  L_integ  { PT _ (TI $$) }
  L_doubl  { PT _ (TD $$) }
  L_quoted { PT _ (TL $$) }
  L_KWVariable { PT _ (T_KWVariable $$) }
  L_KWConstant { PT _ (T_KWConstant $$) }
  L_KWDataPattern { PT _ (T_KWDataPattern $$) }
  L_PIdent { PT _ (T_PIdent _) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read ( $1)) :: Integer }

Double  :: { Double }
Double   : L_doubl  { (read ( $1)) :: Double }

String  :: { String }
String   : L_quoted {  $1 }

KWVariable :: { KWVariable}
KWVariable  : L_KWVariable { KWVariable ($1)}

KWConstant :: { KWConstant}
KWConstant  : L_KWConstant { KWConstant ($1)}

KWDataPattern :: { KWDataPattern}
KWDataPattern  : L_KWDataPattern { KWDataPattern ($1)}

PIdent :: { PIdent}
PIdent  : L_PIdent { PIdent (mkPosToken $1)}

Problem :: { Problem }
Problem : ListBlock { AbsHashedLang.Problem $1 }
Block :: { Block }
Block : VariableBlock { AbsHashedLang.BlockVariable $1 }
      | ConstantBlock { AbsHashedLang.BlockConstant $1 }
ListBlock :: { [Block] }
ListBlock : Block { (:[]) $1 } | Block ListBlock { (:) $1 $2 }
Number :: { Number }
Number : Integer { AbsHashedLang.NumInt $1 }
       | Double { AbsHashedLang.NumDouble $1 }
Val :: { Val }
Val : 'File' '(' String ')' { AbsHashedLang.ValFile $3 }
    | 'Dataset' '(' String ',' String ')' { AbsHashedLang.ValDataset $3 $5 }
    | 'Pattern' '(' KWDataPattern ')' { AbsHashedLang.ValPattern $3 }
    | 'Random' { AbsHashedLang.ValRandom }
    | Number { AbsHashedLang.ValLiteral $1 }
Dim :: { Dim }
Dim : '[' Integer ']' { AbsHashedLang.Dim $2 }
Shape :: { Shape }
Shape : {- empty -} { AbsHashedLang.ShapeScalar }
      | Dim { AbsHashedLang.Shape1D $1 }
      | Dim Dim { AbsHashedLang.Shape2D $1 $2 }
      | Dim Dim Dim { AbsHashedLang.Shape3D $1 $2 $3 }
VariableDecl :: { VariableDecl }
VariableDecl : PIdent Shape { AbsHashedLang.VariableNoInit $1 $2 }
             | PIdent Shape '=' Val { AbsHashedLang.VariableWithInit $1 $2 $4 }
ListVariableDecl :: { [VariableDecl] }
ListVariableDecl : {- empty -} { [] }
                 | VariableDecl { (:[]) $1 }
                 | VariableDecl ',' ListVariableDecl { (:) $1 $3 }
VariableDeclGroup :: { VariableDeclGroup }
VariableDeclGroup : ListVariableDecl { AbsHashedLang.VariableDeclGroup $1 }
ListVariableDeclGroup :: { [VariableDeclGroup] }
ListVariableDeclGroup : {- empty -} { [] }
                      | VariableDeclGroup { (:[]) $1 }
                      | VariableDeclGroup ';' ListVariableDeclGroup { (:) $1 $3 }
VariableBlock :: { VariableBlock }
VariableBlock : KWVariable ':' '{' ListVariableDeclGroup '}' { AbsHashedLang.VariableBlock $1 $4 }
ConstantDecl :: { ConstantDecl }
ConstantDecl : PIdent Shape '=' Val { AbsHashedLang.ConstantDecl $1 $2 $4 }
ListConstantDecl :: { [ConstantDecl] }
ListConstantDecl : {- empty -} { [] }
                 | ConstantDecl { (:[]) $1 }
                 | ConstantDecl ',' ListConstantDecl { (:) $1 $3 }
ConstantDeclGroup :: { ConstantDeclGroup }
ConstantDeclGroup : ListConstantDecl { AbsHashedLang.ConstantDeclGroup $1 }
ListConstantDeclGroup :: { [ConstantDeclGroup] }
ListConstantDeclGroup : {- empty -} { [] }
                      | ConstantDeclGroup { (:[]) $1 }
                      | ConstantDeclGroup ';' ListConstantDeclGroup { (:) $1 $3 }
ConstantBlock :: { ConstantBlock }
ConstantBlock : KWConstant ':' '{' ListConstantDeclGroup '}' { AbsHashedLang.ConstantBlock $1 $4 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

